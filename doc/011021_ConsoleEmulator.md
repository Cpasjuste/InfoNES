更新履歴
- 第1版 (2001/11/21)
- 第2版 (2021/04/14) Markdown化
___

## コンソールエミュレータについて

### あらまし

  
　[FAQ](https://github.com/jay-kumogata/InfoNES/tree/master/doc/011021_FaqOnEmulator.md)に記述したことを，まとめました．

### 1 はじめに

  
　本文書では，コンソールエミュレータ（Console Emulator）を，いくつかの側面（技術的な側面，法的な側面）から解説します．

### 2 概論

  
　本章では，本文書で対象とするコンソールエミュレータについて，どのようなものかを解説します．

#### 2.1 エミュレータとは?

  
　エミュレータ（Emulator）とは，あるハードウェア用に開発されたソフトウェアを動作させることができるソフトウェアのことです．例えば，ファミコンエミュレータでは，ファミコン(tm)用に開発されたカートリッジを動作させて，そのゲームを楽しむことができます．

#### 2.2 コンソールエミュレータとは?

  
　コンソール（Console）とは，ゲーム専用のハードウェアのことです．例えば，SONY PlayStation2(tm)や任天堂GameCube(tm)は，コンソールです．したがって，コンソールエミュレータとは，ゲーム専用機を対象としたエミュレータのことです．

### 3 技術的な側面

  
本章では，筆者が，ファミリーコンピュータ用のエミュレータ（InfoNES[1]）を開発した時に得た知見について解説します． コンソールエミュレータは，通常，下記のようなモジュールから構成されています．近年のゲーム専用機は，もっと複雑な構成をしています．コンソールエミュレータの機能は，下記のモジュールを実装することで，コンソールエミュレータの機能が実現されます．以下では，上記のモジュール毎に，機能概要を説明します．

- CPU（Central Processing Unit）機能を実現するモジュール（CPUエミュレータ）
- メモリユニット(Memory Unit)機能を実現するモジュール（メモリエミュレータ）
- PPU（Picture Processing Unit）機能を実現するモジュール（PPUエミュレータ）
- APU（Audio Processing Unit）機能を実現するモジュール（APUエミュレータ）
- コントローラユニット（Controller Unit）機能を実現するモジュール（コントローラエミュレータ）

#### 3.1 CPUエミュレータ

  
　通常，CPUエミュレータでは，クロック数を管理します．この処理は，他のモジュール（特に，PPUエミュレータ）とタイミングを同期させ，正確なエミュレーションを実現するために必須な処理です．

　一般に，CPUエミュレータは，下記のような構造をしています．

	// 実行すべきクロック数分だけ，命令を実行するCPUエミュレータ用の関数
	cpu_emulator( int CLOCK_TO_EXEC ) 
	{
	  clock_passed = 0;
	  for ( ; ; ) 
	  {
	    // 割り込み(IRQ)のチェック
	    if ( IRQ_Status )
	    {
	      // 割り込み(IRQ)に対応する処理を実行
	      process_for_irq();
	    }
	
	    // PCがポイントするアドレスから命令を読み込み
	    opcode = read( PC++ );
	    // 命令毎に処理を実行
	    switch ( opcode )
	    {
	      case inst1:    // 命令1（例：ADD A, B）の場合
	      inst1();       // 命令1に対応する処理（例：レジスタA，Bの値を加算して，
	      break;         // レジスタAに代入）を実行
	      ...            // すべての命令に関して，同様に処理
	    }
	    // 命令に対応するクロック数を加算する
	    clock_passed += clock[ opcode ];  
	    // 既に実行されたクロック数が規定のクロック数を超えたら終了
	    if ( CLOCK_TO_EXEC < clock_passed )
	　　  break;
	  }
	}

　なお，各変数（各関数）は，下記を意味しています．

|変数名（関数名）|意味|
|----------------|----|
|PC|プログラムカウンタ|
|read()|主記憶（もしくは，メモリマップされたI/O）から値を読み込む関数|
|inst1|命令1に対応するオペコード|
|inst1()|命令1に対応する処理を実行する関数|
|clock_passed|既に経過したクロック数|
|CLOCK_TO_EXEC|実行するべきクロック数|
|clock[]|各命令を実行するのに必要なクロック数を格納した配列|
|IRQ_Status|割り込み(IRQ)が発生したかのフラグ|
|process_for_IRQ()|割り込み(IRQ)発生時の処理|

#### 3.2 メモリエミュレータ

  
　主記憶（例：RAM，ROM）や外部モジュール（PPUエミュレータ，APUエミュレータ，ジョイパッド等）と，CPUエミュレータの通信時に利用されるのが，メモリエミュレータです．

　外部モジュールとの通信時にも，メモリエミュレータが利用されるということで，奇異に思えますが，エミュレーション対象が，メモリマップされたI/O（Memory-mapped I/O）を利用しているときには，一般的な手法です．メモリマップされたI/Oは，メモリ空間以外に独立したI/O空間を用意するのではなく，メモリ空間の一部にI/O空間を配置し，メモリを操作する感覚で，外部モジュールとI/Oできるという特徴があります．

　一般に，メモリエミュレータ（「読み込み」）は，下記のような構造をしています．

	// 指定したアドレスに対応する値を返す関数
	read( addr )
	{
	  // 指定したアドレスがRAM領域を指している場合
	  if ( RAM_TOP <= addr && addr <= RAM_BOTTOM )
	  {
	    return RAM[ addr - RAM_TOP ];
	  } else 
	  // 指定したアドレスがROM領域を指している場合
	  if ( ROM_TOP <= addr && addr <= ROM_BOTTOM )
	  {
	    return ROM[ addr - ROM_TOP ];
	  } else
	  // 指定したアドレスがメモリマップされたI/O領域を指している場合
	  if ( MEMORY_MAPPED_IO_TOP <= addr && add <= MEMORY_MAPPED_IO_BOTTOM )
	  {
	    // メモリマップされたI/O用の読み込み関数を呼び出す
	    return memory_mapped_io_read( addr );
	  }
	}

  
　なお，各変数（各関数）は，下記を意味しています．

|変数名（関数名）|意味|
|----------------|----|
|RAM[]|主記憶（RAM）の内容を格納した配列|
|ROM[]|主記憶（ROM）の内容を格納した配列|
|RAM_TOP|RAM領域の先頭アドレス|
|RAM_BOTTOM|RAM領域の終了アドレス|
|ROM_TOP|ROM領域の先頭アドレス|
|ROM_BOTTOM|ROM領域の終了アドレス|
|MEMORY_MAPPED_IO _TOP|メモリマップされたI/O領域の先頭アドレス|
|MEMORY_MAPPED_IO _BOTTOM|メモリマップされたI/O領域の終了アドレス|
|memory_mapped_io_read()|メモリマップされたI/O用の読み込み処理を実行する関数|

#### 3.3 PPUエミュレータ

  
　PPUエミュレータは，ビデオRAM（VRAM）内のデータを画面に表示する処理を行ないます．その際に，CPUエミュレータとのタイミングを同期させるために，走査線毎に実行するクロックを求めておいて，走査線を描画する度に，そのクロック数分だけ，CPUエミュレータを動作させます．例えば，ファミコンの場合，1走査線，113クロック程度に対応します．

	/* VRAMの内容を1画面分描画する関数 */
	ppu_emulator()
	{
	  /* 走査線の数だけ繰り返し */
	  for ( scanline = 0; scanline < SCANLINE_PER_SCREEN; scanline++ )
	  {
	    /* 1走査線当りのクロック数文だけ，CPUエミュレータを実行 */
	    cpu_emulator( CLOCK_PER_SCANLINE );
	    /* 画面に表示すべき領域の場合 */
	    if ( ON_SCREEN_TOP <= scanline && scanline <= ON_SCREEN_BOTTOM )
	    {
	      /* 対象となる走査線について，VRAMの内容を描画 */
	      draw_line( scanline );
	    } else
	    /* 垂直同期（VSYNC）が開始した場合 */
	    if ( VSYNC_TOP == scanline )
	    {
	      // 垂直同期（VSYNC）が開始された場合の処理
	      start_vsync( scanline );
	      // APUエミュレータの起動
	      apu_emulator();
	    } else
	    ...
	  }
	}

　なお，各変数（各関数）は，下記を意味しています．

|変数名（関数名）|意味|
|----------------|----|
|SCANLINE_PER_SCREEN|1画面に対応する走査線数|
|CLOCK_PER_SCANLINE|1走査線を描画するのに対応するクロック数|
|ON_SCREEN_TOP|画面に表示すべき領域が開始される走査線No.|
|ON_SCREEN_BOTTOM|画面に表示すべき領域が終了する走査線No.|
|VSYNC_TOP|垂直同期（VSYNC）の領域が開始される走査線No.|
|VSYNC_BOTTOM|垂直同期（VSYNC）の領域が終了する走査線No.|
|draw_line()|対応する走査線について，VRAMの内容を描画する関数|
|start_vsync()|垂直同期（VSYNC）が開始された時の関数（後述）|
|cpu_emulator|指定されたクロック数分だけCPUエミュレータを実行する関数|

  
　通常，画面のちらつきを避けるために，VRAMは垂直同期（VSYNC）中に変更されます．したがって，ゲーム等のアプリケーション側では，垂直同期（VSYNC）を待ってから，画面更新（VRAM変更）を行なう必要があります．このため，PPUは，垂直同期（VSYNC）中か否かの情報（VSYNCフラグ）を，現在の状態として保持しており，アプリケーション側は，メモリマップされたI/Oを経由して，その情報を読み出せるようにしてあります．

　また，垂直同期（VSYNC）が開始された時の処理としては，下記があります．

-   VSYNCフラグを立てる
-   APUエミュレータを呼び出す
-   コントローラ（例：ジョイパッド）エミュレータを呼び出す

#### 3.4 APUエミュレータ

  
　一般に，APUエミュレータは，下記のような構造をしています．

	// 垂直同期（VSYNC）が開始された時に呼び出されるAPUエミュレータ
	apu_emulator()
	{
	  // 前回の垂直同期（VSYNC）から，今回の垂直同期（VSYNC）まで
	  for ( int time = PREV_VSYNC_TIME; time < NOW_TIME; time++ )
	  {
	    // エベントキューの先頭イベントの時間をチェック
	    if ( event_queue[ ptr ].time == time )
	    {
	      // 周波数レジスタ，ボリュームレジスタを更新
	      update_frequency( event_queue[ ptr ] );
	      update_volume( event_queue[ ptr ]);
	      // イベントキューの先頭ポインタを更新
	      ptr++;
	    }
	    // 単位時間分の波形をレンダリング
	    wave_render( time, frequency, volume );
	  }
	  // レンダリングした波形を音声デバイスに出力
	  output_wave();
	}

　前述したように，APUエミュレータは，垂直同期（VSYNC）毎に呼び出されます．通常，APUエミュレータは，前回の垂直同期（VSYNC）から現在の垂直同期（VSYNC）の間に発生したイベント（例：周波数レジスタ，ボリュームレジスタの変更）を時系列で管理しているので，この情報をもとにして，波形をレンダリングし，バッファリングしつつ，音声デバイスに出力します．ここで，バッファリングしないと，音が途切れ（「プチノイズ」）の原因となります．

　各変数（各関数）は，下記を意味しています．

|変数名（関数名）|意味|
|----------------|----|
|PREV_VSYNC_TIME|前回，垂直同期（VSYNC）が開始された時刻|
|NOW_TIME|現在の時刻|
|Frequency|周波数レジスタ|
|Volume|ボリュームレジスタ|
|update_frequency()|周波数レジスタを更新する関数|
|update_volume()|ボリュームレジスタを更新する関数|
|event_queue[]|発生したイベントを構造体に格納したキュー（イベントキュー）|
|event_queue[].time|イベントが発生した時刻|
|ptr|イベントキューの先頭ポインタ|
|wave_render()|周波数レジスタ，ボリュームレジスタを用いて，時刻timeから時刻time+1までの波形をレンダリングする関数|
|output_wave()|レンダリングされた波形の音声デバイスへの出力する関数|

#### 3.5 コントローラエミュレータ

  
　現在，執筆中です．

### 4 法的な側面

#### 4.1 エミュレータの違法性

  
　エミュレータを開発すること自体は，合法だと言われています．ただし，具体的な判例があるわけではなく，実際には，グレーだと思います．

　一方，ゲームカートリッジのROMイメージ（BIOSイメージ）は，その開発者が，著作権を所有しているので，ROMイメージを配布したり，自分が所有していないゲームカートリッジのROMイメージを所有することは，明らかに違法です．問題は，自分の所有しているゲームカートリッジのROMイメージを，インターネットからダウンロードしてくることを，違法とする説と，合法とする説があります．ただ，最近は，違法とする説の方が，有力です．

　上記のROMイメージの問題があるので，エミュレータ＝違法というイメージが定着している背景があります．

　また，SONY PlayStation（プレステ）のエミュレータに関しては，不正競争防止法の問題があります．不正競争防止法では，プロテクト外しに相当する行為を違法であると定めています．例えば，プレステでは，コピーしたゲームCD-ROMを実行できないようなプロテクトがかかってますが，それを無効化するMODチップなどは，不正競争防止法違反になります．

　一方で，プレステエミュレータは，コピーされたゲームCD-ROMも実行できるため，この点を指摘して，プレステエミュレータ=不正競争防止法違反とする議論もあるようです（特に，SCEI社は，bleem!の国内代理店に対して，上記のような理由で，販売の停止を求めているようです）．

### 参考文献

  

- [1] [Jay's Factory: "InfoNES for Win32, Linux(x86), Linux(PS2).](https://github.com/jay-kumogata/InfoNES)
- [2] 原田, 枝, 高橋: "ドリキャスはプレステか?", 日経エレクトロニクス 2000.8.28 (no.777), pp.137-164.

___

Copyright (c) 1999-2001 Jay's Factory / 2021 Kumogata Jay. All Rights Reserved.